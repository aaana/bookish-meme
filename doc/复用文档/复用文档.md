# 复用文档

## 项目组成员

| 学号 | 姓名 | Github |
| -----|:----:| ----:|
| 1352892    | 谭靖儒    | [tztztztztz](https://github.com/tztztztztz) |
| 1352875    | 黄安娜    | [aaana](https://github.com/aaana)           |
| 1352965    | 晁佳欢    | [wlmxjm1](https://github.com/wlmxjm1)       |
| 1352923    | 马致远    | [maerye](https://github.com/maerye)         |
| 1352965    | 林昌盛    | [apelyn](https://github.com/apelyn)         |

## 文档信息
|文档编号|文档名称|版本号|正式发布|时间|
|:----:|:----:|:----:|:----:|:----:|
|3|复用文档|v5.0|正式发布|2016.06.01|

## 文档修改记录
|日期|版本|说明|修改人员|评审人员|
|:----:|:----:|:----:|:----:|:----:|
|2016.03.29|v1.0|标识可复用构件、冗余检查|黄安娜|全体成员|
|2016.04.06|v2.0|添加可复用构件开发与发布(PM,CM,LICENSE,DATABASE)|黄安娜|全体成员|
|2016.04.10|v3.0|选择可复用构件(PM,CM,LICENSE)|黄安娜|全体成员|
|2016.05.07|v4.0|识别出新的可复用构件并进行开发(CIPHER,COMPRESS)|黄安娜|全体成员|
|2016.05.29|v5.0|选择拆分Server时使用的构件Java RMI|黄安娜|全体成员|

##主要内容
- [可复用构件](#可复用构件)
- [识别可复用构件](#识别可复用构件)
	- [识别原则](#识别原则)
	- [识别出的可复用构件](#识别出的可复用构件)
		- [系统的构件](#系统的构件)
		- [项目管理和文档](#项目管理和文档)
- [可复用构件开发与发布](#可复用构件开发与发布)
	- PM
	- CM
	- LICENSE
	- DATABASE
	- CIPHER
	- COMPRESS
- [选择可复用构件](#选择可复用构件)
- [冗余检查](#冗余检查)

### 可复用构件
`能被用于开发各种可交付的系统项目的可以被复用的软件成分`
	- 它可以是从旧的软件中提取的，也可以是专门为了复用而开发的
	- 一个软件构件只有在多个系统中能够被使用才称得上名副其实的可复用构件

### 识别可复用构件

#### 识别原则
	- 一部分是系统的构件，诸如设计和代码的构件
	- 另一部分是有关的项目管理和文档

#### 识别出的可复用构件
- 系统的构件
	- 系统体系结构：
		- netty框架，而不是用socket重新写   
		- 前后端通过EventBus机制解耦
		- 将功能划分为不同的低耦合、高内聚的模块单独实现（channel中有一系列顺序流过的handler来分别实现不同的功能，而不是一个handler实现所有的功能）
	- UI设计构件
	- 配置文件读取构件(CM构件)
	- 数据库连接构件(DATABASE构件)
	- 性能管理模块(PM构件)
	- 速率限制许可证模块(License模块)
	- 文件加密解密模块(CIPHER构件)
	- 文件压缩模块(COMPRESS构件)
	 	
- 项目管理和文档 
	- 项目管理模式
	- 文档构件：项目管理文档，项目计划表
	- 测试数据：测试用例设计
	
### 可复用构件开发与发布
生成jar包
- PM构件 <https://github.com/bookish-component/PM>
	- 接收应用程序的性能指标（指标名称，指标数值）
	- 每分钟自动生成性能报告
	- 性能报告输出到单独的性能文件，文件名包括性能报告时间
	- 功能扩展
		- Server/Client保存所有收到的消息到文件
         	- 文件格式不限
         	- 文件路径可配置
        - 实现文件压缩功能

- CM构件 <https://github.com/bookish-component/CM>
	- 从文件中读取参数配置
	- 提供查询接口
	- 动态加载
- LICENSE构件 <https://github.com/bookish-component/License>
	- 每收到一个请求，计数加1
	- 根据已经收到的消息数量和预设的数值，判断是否可以继续提供服务
		- Throughput
		- Capacity
- DATABASE构件 <https://github.com/bookish-component/SQLHelper>
- CIPHER构件 <https://github.com/bookish-component/CIPHER>
- COMPRESS构件 <https://github.com/bookish-component/COMPRESS>

### 选择可复用构件
详细内容见`可复用构件选择及改进建议`文档
#### CM构件
`选择构件－－Team5`
[Team5](https://github.com/SummerWish/Tahiti)

##### 选择理由
|小组|说明|选择与否|理由|
|:----:|:----:|:----:|:----:|
|Team1|支持ini格式以及动态加载，可以读取并写入配置|✕|项目原本采用的是json配置，想要在不修改配置文件类型的情况下进行使用|
|Team2|支持Json格式|✕|每次使用都要指定文件路径，且不支持嵌套配置的读取|
|Team3|支持Json格式|✕|参数已经确定，扩展性差|
|Team4||✕|文档不全|
|Team5|支持Json和Yaml两种格式|✓|配置文件读取是直接读成Java对象，这与我们之前没有构建CM构件时的方法相同，也就是说我们之前已经创建了Config这个Java bean了，使用起来就很方便
|Team6|文件读取方式|✕|不支持我们的配置文件格式|
|Team7||✕|参数已经确定，扩展性差|
|Team8||✕|文档太简单了|
|Team10|支持json|✕|不支持嵌套配置的读取|
|Team11|支持json|✕|不支持嵌套配置的读取|

##### 改进建议
- 无法读取嵌套配置
- 可以添加更多的接口，不仅可以直接读成Java bean，也可以根据键来读值

#### PM构件

选择构件 Team5

##### 第一次选择

##### 选择理由
1. 方便使用，与系统耦合低，可以很方便使用到我们的构建中，因为我们的pm部分是由一个单独的类处理，整体改动就非常少
2. 尝试过第4组的pm，但是不能自定义字段，只能记录成功与失败，无法很好的适应该项目

##### 改进建议
希望能够自自定义输出路径或者格式

##### 第二次选择

由于项目需要加入对PM生成的文档进行压缩归档，我们与第五组进行了相关的交流，知道了第五组已经有了相关的功能，交流后，第五组也把相关的文档写在了readme上面。

同时，我们发现第五组的项目版本也做了更新，由原来的1.0.SNAPSHOT到了1.1.SNAPSHOT,而且第五组使用的是maven仓库下载，我们不需要重新下载jar包，而只需要在.pom下改版本号就可以了，非常的方便


#### License构件
 `选择构件——Team2`
##### 选择理由
与本项目原构件使用方法基本一致，无需改变原代码结构，使用方便。
##### 改进建议
- 对参数提供set和get方法，使用起来就可以更加的灵活。
- 改变一下类名，MaxNumOfMessage这个类听起来不像是一个限制器，更像是一个数值，容易让人混淆。

#### JAVA RMI可复用构件
分拆Server时，选择可复用构件——Java RMI中间件

### 冗余检查
- 过程冗余：由于登陆消息和聊天消息公用一条pipeline，所以消息在channel中流动时会有冗余，但这种冗余反而降低了设计的复杂度，是可接受的。
